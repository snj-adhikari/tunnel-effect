<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tube Website Experience</title>
    <!-- Tailwind CSS CDN for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Inter font from Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        /* Custom CSS for the page */

        .section-content {
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            text-align: center;
            max-width: 80%; /* Limit the width to 80% of the screen */
            width: 100%; /* Ensure it takes full width up to the max-width */
            height: calc(var(--vh, 1vh) * 100); /* Use dynamic viewport height for mobile */
            background: transparent;
            margin: 0 auto; /* Center horizontally */
            padding: 1rem; /* Add some padding for better responsiveness */
            box-sizing: border-box; /* Include padding in width calculations */
            opacity: 0; /* Initially hidden */
            transform: scale(0.5); /* Start scaled down for the traverse effect */
            transition: opacity 0.5s ease-in-out, transform 0.5s ease-in-out; /* Animate opacity and scale */
        }

        /* Ensure the scrollable content extends beyond the viewport to enable scrolling */
        #scroll-content-wrapper {
            /* This height will be dynamically set by JS to enable scrolling */
            min-height: 100vh; /* Minimum height, will be adjusted */
        }

        #three-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1; /* Below content overlay */
        }

        #scroll-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            overflow-y: hidden; /* Disable the native scrollbar */
            z-index: 2; /* Above Three.js canvas */
        }
    </style>
</head>
<body>
    <!-- Container for the Three.js canvas -->
    <div id="three-container"></div>

    <!-- Scrollable container for the HTML content overlay -->
    <div id="scroll-container">
        <div id="scroll-content-wrapper">
            <!-- Sample Content Sections -->
            <section id="section1" class="section-content" data-scroll-start="0" data-scroll-end="0.2">
                <h1 class="text-5xl md:text-7xl font-bold mb-4">Welcome to the Tube Journey!</h1>
                <p class="text-lg md:text-xl max-w-2xl">
                    Explore our immersive experience as you traverse through a mystical tube.
                    Scroll down to begin your adventure.
                </p>
                <button class="mt-8 px-6 py-3 bg-blue-600 hover:bg-blue-700 text-white font-semibold rounded-full shadow-lg transition duration-300">
                    Start Exploring
                </button>
            </section>

            <section id="section2" class="section-content" data-scroll-start="0.2" data-scroll-end="0.4">
                <h2 class="text-4xl md:text-6xl font-bold mb-4">Our Mission</h2>
                <p class="text-lg md:text-xl max-w-2xl">
                    We aim to redefine web navigation by blending stunning visuals with seamless interaction.
                    Each twist and turn reveals new insights.
                </p>
                <div class="mt-8 grid grid-cols-1 md:grid-cols-3 gap-6">
                    <div class="bg-gray-800 p-6 rounded-lg shadow-md">
                        <h3 class="text-2xl font-semibold mb-2">Innovation</h3>
                        <p>Pushing the boundaries of web design.</p>
                    </div>
                    <div class="bg-gray-800 p-6 rounded-lg shadow-md">
                        <h3 class="text-2xl font-semibold mb-2">Experience</h3>
                        <p>Crafting unforgettable user journeys.</p>
                    </div>
                    <div class="bg-gray-800 p-6 rounded-lg shadow-md">
                        <h3 class="text-2xl font-semibold mb-2">Simplicity</h3>
                        <p>Complex ideas, elegantly presented.</p>
                    </div>
                </div>
            </section>

            <section id="section3" class="section-content" data-scroll-start="0.4" data-scroll-end="0.6">
                <h2 class="text-4xl md:text-6xl font-bold mb-4">What You'll Discover</h2>
                <p class="text-lg md:text-xl max-w-2xl">
                    From captivating articles to interactive elements, every segment of the tube holds a surprise.
                    Prepare to be amazed!
                </p>
                <ul class="mt-8 text-left space-y-4 text-lg md:text-xl">
                    <li>âœ¨ Immersive Visuals</li>
                    <li>ðŸš€ Seamless Navigation</li>
                    <li>ðŸ’¡ Engaging Content</li>
                    <li>ðŸ”’ Secure Environment</li>
                </ul>
            </section>

            <section id="section4" class="section-content" data-scroll-start="0.6" data-scroll-end="0.8">
                <h2 class="text-4xl md:text-6xl font-bold mb-4">Get Started</h2>
                <p class="text-lg md:text-xl max-w-2xl">
                    Ready to embark on your own journey? Join our community and start creating!
                </p>
                <form class="mt-8 w-full max-w-md bg-gray-800 p-8 rounded-lg shadow-md">
                    <div class="mb-4">
                        <label for="name" class="block text-white text-sm font-bold mb-2">Name:</label>
                        <input type="text" id="name" name="name" class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline" placeholder="Your Name">
                    </div>
                    <div class="mb-6">
                        <label for="email" class="block text-white text-sm font-bold mb-2">Email:</label>
                        <input type="email" id="email" name="email" class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 mb-3 leading-tight focus:outline-none focus:shadow-outline" placeholder="your@example.com">
                    </div>
                    <button type="submit" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-full focus:outline-none focus:shadow-outline transition duration-300">
                        Sign Up
                    </button>
                </form>
            </section>

            <section id="section5" class="section-content" data-scroll-start="0.56" data-scroll-end="0.70">
                <h2 class="text-4xl md:text-6xl font-bold mb-4">Contact Us</h2>
                <p class="text-lg md:text-xl max-w-2xl">
                    Have questions or feedback? We'd love to hear from you.
                </p>
                <div class="mt-8 flex flex-col md:flex-row gap-6">
                    <a href="#" class="px-6 py-3 bg-purple-600 hover:bg-purple-700 text-white font-semibold rounded-full shadow-lg transition duration-300">
                        Email Us
                    </a>
                    <a href="#" class="px-6 py-3 bg-red-600 hover:bg-red-700 text-white font-semibold rounded-full shadow-lg transition duration-300">
                        Follow on X
                    </a>
                </div>
            </section>

            <section id="section6" class="section-content" data-scroll-start="0.70" data-scroll-end="0.84">
                <h2 class="text-4xl md:text-6xl font-bold mb-4">Our Community</h2>
                <p class="text-lg md:text-xl max-w-2xl">
                    Join a vibrant community of creators and innovators.
                </p>
            </section>

            <section id="section7" class="section-content" data-scroll-start="0.84" data-scroll-end="1.0">
                <h2 class="text-4xl md:text-6xl font-bold mb-4">The End of the Line</h2>
                <p class="text-lg md:text-xl max-w-2xl">
                    You\'ve reached the destination, but the journey never truly ends.
                </p>
            </section>
        </div>
    </div>

    <!-- Three.js CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Three.js variables
        let scene, camera, renderer, tubeMesh, curve, pointLight;
        let scrollContainer, scrollContentWrapper, contentSections;
        let currentSectionIndex = 0;
        let isAnimating = false; // To prevent scroll spam
        let touchStartY = 0; // For mobile touch events
        let particles, particleVelocities; // For moving particles
        let endOfTunnelLight; // Light at the end of the tunnel
        let debrisMeshes = []; // To store and animate debris

        // Function to set the viewport height dynamically for mobile
        function setViewportHeight() {
            const vh = window.innerHeight * 0.01;
            document.documentElement.style.setProperty('--vh', `${vh}px`);
        }

        // Function to create a glowing line texture
        function createLineTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 128; // Texture width
            canvas.height = 128; // Texture height
            const context = canvas.getContext('2d');

            // Draw a black background
            context.fillStyle = '#000000';
            context.fillRect(0, 0, canvas.width, canvas.height);

            // Draw white vertical lines
            context.strokeStyle = '#FFFFFF'; // White lines
            context.lineWidth = 2; // Line thickness
            const lineSpacing = 16; // Space between lines

            for (let x = 0; x < canvas.width; x += lineSpacing) {
                context.beginPath();
                context.moveTo(x, 0);
                context.lineTo(x, canvas.height);
                context.stroke();
            }

            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            return texture;
        }

        // Add particles to the background
        function addParticles() {
            const particleCount = 1200; // Increased particle count for denser feel
            const particleGeometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            particleVelocities = [];

            for (let i = 0; i < particleCount; i++) {
                positions[i * 3] = (Math.random() - 0.5) * 150;
                positions[i * 3 + 1] = (Math.random() - 0.5) * 150;
                positions[i * 3 + 2] = (Math.random() - 0.5) * 150;
                particleVelocities.push(new THREE.Vector3(
                    (Math.random() - 0.5) * 0.03,
                    (Math.random() - 0.5) * 0.03,
                    (Math.random() - 0.5) * 0.03
                ));
            }
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

            const particleMaterial = new THREE.PointsMaterial({
                color: 0x8B4513, // Dirt/saddle brown color
                size: 0.2, // Slightly larger particles
                transparent: true,
                opacity: 0.6,
                blending: THREE.AdditiveBlending
            });

            particles = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(particles);
        }

        // Function to create a realistic leaf mesh with a crease
        function createLeafMesh() {
            const leafShape = new THREE.Shape();
            // Define the leaf outline with a crease
            leafShape.moveTo(0, 0);
            leafShape.quadraticCurveTo(0.1, 0.1, 0.2, 0.4);
            leafShape.quadraticCurveTo(0.05, 0.6, 0, 0.8); // Tip
            leafShape.quadraticCurveTo(-0.05, 0.6, -0.2, 0.4);
            leafShape.quadraticCurveTo(-0.1, 0.1, 0, 0); // Back to base

            const extrudeSettings = {
                steps: 1,
                depth: 0.02,
                bevelEnabled: true,
                bevelThickness: 0.01,
                bevelSize: 0.01,
                bevelSegments: 1
            };

            const leafGeom = new THREE.ExtrudeGeometry(leafShape, extrudeSettings);
            const leafMat = new THREE.MeshPhysicalMaterial({
                color: 0x556B2F, // Darker, more realistic green
                roughness: 0.8,
                side: THREE.DoubleSide,
                transmission: 0.4,
                opacity: 0.9,
                transparent: true
            });
            const leaf = new THREE.Mesh(leafGeom, leafMat);
            leaf.castShadow = true;
            return leaf;
        }

        // Function to create a realistic, multi-part branch mesh with leaves
        function createBranchMesh() {
            const branchGroup = new THREE.Group();
            const branchMat = new THREE.MeshPhysicalMaterial({
                color: 0x3C2A1E, // Darker, more realistic brown
                roughness: 0.9,
                metalness: 0.1
            });

            // Main branch
            const mainGeom = new THREE.CylinderGeometry(0.08, 0.12, 4, 8);
            const mainBranch = new THREE.Mesh(mainGeom, branchMat);
            mainBranch.castShadow = true;
            branchGroup.add(mainBranch);

            // Add smaller sub-branches and leaves
            const subBranchCount = 2 + Math.floor(Math.random() * 2);
            for (let i = 0; i < subBranchCount; i++) {
                const subGeom = new THREE.CylinderGeometry(0.04, 0.06, 2, 6);
                const subBranch = new THREE.Mesh(subGeom, branchMat);
                subBranch.position.y = (Math.random() - 0.5) * 1.5;
                subBranch.position.x = (Math.random() - 0.5) * 0.2;
                subBranch.rotation.z = (Math.random() - 0.5) * Math.PI / 2;
                subBranch.rotation.x = (Math.random() - 0.5) * Math.PI / 2;
                subBranch.castShadow = true;
                mainBranch.add(subBranch);

                // Add a leaf to the sub-branch
                if (Math.random() > 0.3) {
                    const leaf = createLeafMesh();
                    const leafScale = 0.5 + Math.random() * 0.5;
                    leaf.scale.set(leafScale, leafScale, leafScale);
                    leaf.position.y = 1; // Tip of the sub-branch
                    leaf.rotation.x = Math.PI / 2;
                    subBranch.add(leaf);
                }
            }

            return branchGroup;
        }

        // Function to add random 3D debris like leaves and branches
        function addRandomDebris(curve, count) {
            for (let i = 0; i < count; i++) {
                const t = Math.random();
                const pos = curve.getPointAt(t);
                const tangent = curve.getTangentAt(t);

                let object;
                let scale = 0.8 + Math.random() * 0.4; // Randomize scale

                // Randomly decide to create a leaf or a branch
                if (Math.random() > 0.6) {
                    // Create a realistic leaf
                    object = createLeafMesh();
                } else {
                    // Create a realistic branch
                    object = createBranchMesh();
                    scale *= 0.8; // Branches are a bit smaller overall
                }

                object.scale.set(scale, scale, scale);
                object.position.copy(pos);
                object.position.add(new THREE.Vector3(
                    (Math.random() - 0.5) * 18,
                    (Math.random() - 0.5) * 18,
                    (Math.random() - 0.5) * 18
                ));
                object.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), tangent);
                object.rotation.x += Math.random() * Math.PI;
                object.rotation.z += Math.random() * Math.PI;
                scene.add(object);
                debrisMeshes.push(object); // Store debris for animation
            }
        }

        // Function to create a procedural bone-like normal map
        function createBoneNormalMap() {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');
            for (let y = 0; y < 256; y++) {
                for (let x = 0; x < 256; x++) {
                    // Simulate bone texture with irregular noise
                    const value = Math.floor(180 + 40 * Math.sin(x * 0.13 + y * 0.07) + 30 * Math.random());
                    ctx.fillStyle = `rgb(${value},${value},255)`;
                    ctx.fillRect(x, y, 1, 1);
                }
            }
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            return texture;
        }

        // Function to create a procedural rope-like normal map for texture
        function createRopeNormalMap() {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');
            const imageData = ctx.createImageData(256, 256);
            const data = imageData.data;

            for (let y = 0; y < 256; y++) {
                for (let x = 0; x < 256; x++) {
                    // Generate a pattern that looks like twisted rope fibers
                    const angle = (x + y * 4) * Math.PI / 32;
                    const nx = Math.cos(angle) * 127 + 128; // Normal X component
                    const ny = Math.sin(angle) * 127 + 128; // Normal Y component
                    const nz = 255; // Normal Z component (pointing out)
                    const index = (y * 256 + x) * 4;
                    data[index] = nx;
                    data[index + 1] = ny;
                    data[index + 2] = nz;
                    data[index + 3] = 255; // Alpha
                }
            }
            ctx.putImageData(imageData, 0, 0);
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(4, 8); // Repeat the texture along the rope
            return texture;
        }

        // Remove the smooth tube mesh (do not add tubeMesh to scene)
        // Instead, build the tunnel from rib arcs forming the wall
        function addSkeletonTunnel(curve, ribCount, tunnelRadius) {
            for (let i = 0; i < ribCount; i++) {
                const t = i / ribCount;
                const pos = curve.getPointAt(t);
                const tangent = curve.getTangentAt(t);
                const axis = new THREE.Vector3(0, 1, 0);
                const quaternion = new THREE.Quaternion().setFromUnitVectors(axis, tangent.clone().normalize());
                // Rib arc: a half-torus, open at the bottom
                const ribGeom = new THREE.TorusGeometry(tunnelRadius, 0.18 + Math.random() * 0.08, 16, 64, Math.PI * (1.2 + Math.random() * 0.2));
                const ribMat = new THREE.MeshPhysicalMaterial({
                    color: 0xf7e7c6,
                    roughness: 0.7,
                    metalness: 0.1,
                    transmission: 0.4,
                    thickness: 0.5,
                    ior: 1.3,
                    clearcoat: 0.3,
                    clearcoatRoughness: 0.5,
                    opacity: 0.97,
                    transparent: true
                });
                const rib = new THREE.Mesh(ribGeom, ribMat);
                rib.position.copy(pos);
                rib.quaternion.copy(quaternion);
                rib.rotation.z = Math.PI / 2 + (Math.random() - 0.5) * 0.2; // Open side down, slight random tilt
                rib.position.x += (Math.random() - 0.5) * tunnelRadius * 0.15;
                rib.position.y += (Math.random() - 0.5) * tunnelRadius * 0.1;
                scene.add(rib);
            }
        }

        // Optionally, add a central spine
        function addSpine(curve, vertebraeCount) {
            for (let i = 0; i < vertebraeCount; i++) {
                const t = i / vertebraeCount;
                const pos = curve.getPointAt(t);
                const tangent = curve.getTangentAt(t);
                const axis = new THREE.Vector3(0, 1, 0);
                const quaternion = new THREE.Quaternion().setFromUnitVectors(axis, tangent.clone().normalize());
                // Vertebra: a squashed sphere or short cylinder
                const vertebraGeom = new THREE.SphereGeometry(0.35 + Math.random() * 0.1, 16, 12);
                const vertebraMat = new THREE.MeshPhysicalMaterial({
                    color: 0xf7e7c6,
                    roughness: 0.6,
                    metalness: 0.1,
                    transmission: 0.3,
                    thickness: 0.5,
                    ior: 1.3,
                    clearcoat: 0.2,
                    clearcoatRoughness: 0.5,
                    opacity: 0.98,
                    transparent: true
                });
                const vertebra = new THREE.Mesh(vertebraGeom, vertebraMat);
                vertebra.position.copy(pos);
                vertebra.quaternion.copy(quaternion);
                vertebra.position.y -= 0.2; // Slightly below center
                scene.add(vertebra);
            }
        }

        // Remove bone/rib/spine/cocoon functions
        // Add a function to generate a 3D web tunnel made of threads
        function addWebTunnel(curve, tunnelRadius, threadCount, threadSegments) {
            const ropeNormalMap = createRopeNormalMap(); // Create the texture once

            for (let i = 0; i < threadCount; i++) {
                const startT = Math.random() * 0.95;
                let endT = startT + 0.05 + Math.random() * 0.2;
                if (endT > 1) endT = 1;
                const points = [];
                const spiralTurns = 2 + Math.floor(Math.random() * 3);
                for (let j = 0; j <= threadSegments; j++) {
                    let t = startT + (endT - startT) * (j / threadSegments);
                    t = Math.max(0, Math.min(1, t));
                    const base = curve.getPointAt(t);
                    const tangent = curve.getTangentAt(t).normalize();
                    let normal = new THREE.Vector3(0, 1, 0);
                    if (Math.abs(tangent.y) > 0.9) normal = new THREE.Vector3(1, 0, 0);
                    const binormal = new THREE.Vector3().crossVectors(tangent, normal).normalize();
                    normal = new THREE.Vector3().crossVectors(binormal, tangent).normalize();
                    const angle = spiralTurns * Math.PI * 2 * (j / threadSegments) + Math.random() * Math.PI * 0.2;
                    const r = tunnelRadius * (0.97 + Math.sin(angle * 2 + t * 10) * 0.04 + Math.random() * 0.04);
                    const offset = normal.clone().multiplyScalar(Math.cos(angle) * r)
                        .add(binormal.clone().multiplyScalar(Math.sin(angle) * r));
                    points.push(base.clone().add(offset));
                }
                const threadCurve = new THREE.CatmullRomCurve3(points);
                const threadGeom = new THREE.TubeGeometry(threadCurve, threadSegments * 2, 0.16 + Math.random() * 0.08, 10, false); // Thicker threads
                const threadMat = new THREE.MeshPhysicalMaterial({
                    color: 0x3C2A1E, // Darker, more realistic brown
                    roughness: 0.9, // Increased roughness for a more matte and rough finish
                    metalness: 0.05, // Reduced metalness
                    transmission: 0.0, // No silkiness
                    thickness: 0.18,
                    ior: 1.2,
                    clearcoat: 0.0, // No clearcoat for matte
                    clearcoatRoughness: 1.0,
                    opacity: 0.98,
                    transparent: true,
                    emissive: 0x000000, // No glow
                    emissiveIntensity: 0.0,
                    normalMap: ropeNormalMap, // Apply the rope texture
                    normalScale: new THREE.Vector2(0.5, 0.5) // Increased texture depth for more roughness
                });
                const thread = new THREE.Mesh(threadGeom, threadMat);
                thread.castShadow = true; // Ropes cast shadows
                thread.receiveShadow = true; // Ropes can have shadows cast on them
                scene.add(thread);
            }
        }

        // Restore tube geometry for the main tunnel
        let tubeGeometry;
        const tubeRadius = 3.5; // Reduced radius for a tighter, more compact tunnel
        const tubularSegments = 200;
        function createTunnel() {
            tubeGeometry = new THREE.TubeGeometry(curve, tubularSegments, tubeRadius, 32, false); // More segments for smoothness
            const tubeMaterial = new THREE.MeshPhysicalMaterial({
                color: 0x0A0A0A, // Even darker tunnel wall
                roughness: 0.95,
                metalness: 0.05,
                transmission: 0.1,
                thickness: 0.3,
                ior: 1.1,
                clearcoat: 0.2,
                clearcoatRoughness: 0.8,
                opacity: 0.65, // Slightly more opaque for deeper shadows
                transparent: true,
                side: THREE.BackSide
            });
            tubeMesh = new THREE.Mesh(tubeGeometry, tubeMaterial);
            tubeMesh.receiveShadow = true; // The tunnel wall receives shadows from the ropes
            scene.add(tubeMesh);
        }

        // Extend the tunnel to the very end
        function extendTunnelToEnd() {
            const endPoint = curve.getPointAt(1); // Get the last point of the curve
            const tangent = curve.getTangentAt(1).normalize();
            const tunnelEndGeom = new THREE.CylinderGeometry(tubeRadius, tubeRadius, 2, 32);
            const tunnelEndMat = new THREE.MeshPhysicalMaterial({
                color: 0x0A0A0A, // Match the tunnel wall color
                roughness: 0.95,
                metalness: 0.05,
                opacity: 0.65,
                transparent: true,
                side: THREE.DoubleSide
            });
            const tunnelEnd = new THREE.Mesh(tunnelEndGeom, tunnelEndMat);
            tunnelEnd.position.copy(endPoint);
            tunnelEnd.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), tangent);
            scene.add(tunnelEnd);
        }

        // Ensure particles are visible throughout the tunnel
        function ensureParticlesVisibility() {
            particles.geometry.attributes.position.array.forEach((_, i) => {
                if (particles.geometry.attributes.position.array[i] > 75 || particles.geometry.attributes.position.array[i] < -75) {
                    particles.geometry.attributes.position.array[i] = (Math.random() - 0.5) * 150;
                }
            });
            particles.geometry.attributes.position.needsUpdate = true;
        }

        // Initialize the Three.js scene
        function initThree() {
            // Scene setup
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x000000, 20, 75); // Adjusted fog for smaller tunnel

            // Camera setup
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 0); // Start at the beginning of the tube

            // Renderer setup
            renderer = new THREE.WebGLRenderer({ antialias: true }); // Set alpha to true for a transparent background
            renderer.setClearColor(0xffffff, 1); // Set clear color to transparent
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true; // Enable shadows
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Softer shadows
            document.getElementById('three-container').appendChild(renderer.domElement);

            // Create the tube path using a CatmullRomCurve3
            const points = [];
            const tubeLength = 50; // Total length of the tube (reduced)
            const numPoints = 50;   // Number of points defining the curve

            for (let i = 0; i <= numPoints; i++) {
                const x = Math.sin(i * 0.2) * 5; // Wavy path on X
                const y = Math.cos(i * 0.15) * 5; // Wavy path on Y
                const z = (i / numPoints) * -tubeLength; // Linear progression along Z-axis (negative for forward movement)
                points.push(new THREE.Vector3(x, y, z));
            }

            curve = new THREE.CatmullRomCurve3(points);

            // Dramatic, eerie lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.5); // Cooler, more subtle ambient light
            scene.add(ambientLight);
            pointLight = new THREE.PointLight(0xffffff, 2.0, 100); // Slightly adjusted intensity and distance
            pointLight.castShadow = true; // The main light casts shadows
            pointLight.shadow.mapSize.width = 1024; // Shadow quality
            pointLight.shadow.mapSize.height = 1024;
            pointLight.shadow.bias = -0.001; // Helps prevent shadow artifacts
            scene.add(pointLight);
            const dirLight = new THREE.DirectionalLight(0x888899, 0.8); // Cooler directional light
            dirLight.position.set(10, 20, 10);
            scene.add(dirLight);

            // Add a light at the very end of the tunnel
            endOfTunnelLight = new THREE.PointLight(0xffffff, 5, 50);
            endOfTunnelLight.position.copy(curve.getPointAt(1));
            scene.add(endOfTunnelLight);

            // Add web tunnel threads AFTER curve is initialized
            addWebTunnel(curve, tubeRadius, 240, 36); // Increased thread count for more compact rings
            createTunnel(); // Add the shadowy tunnel wall
            addRandomDebris(curve, 50); // Increased number of debris objects for a forest feel

            // Get HTML elements
            scrollContainer = document.getElementById('scroll-container');
            scrollContentWrapper = document.getElementById('scroll-content-wrapper');
            contentSections = document.querySelectorAll('.section-content');

            // Set the scrollable height to enable snapping between sections
            scrollContentWrapper.style.height = `${contentSections.length * 100}vh`;

            // Initial update of camera and content positions
            updateSceneAndContent();

            // Event listeners
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('wheel', onWheel, { passive: false }); // Use wheel event for controlled scrolling
            window.addEventListener('touchstart', onTouchStart, { passive: false });
            window.addEventListener('touchend', onTouchEnd, { passive: false });

            addParticles();

            // Debugging logs to identify issues
            console.log('Initializing Three.js with section-based scroll...');
        }

        // Handle window resize
        function onWindowResize() {
            setViewportHeight(); // Adjust height on resize
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);

            // Re-adjust scrollable height on resize
            scrollContentWrapper.style.height = `${contentSections.length * 100}vh`;

            // Snap to the current section's position after resize
            scrollContainer.scrollTop = currentSectionIndex * window.innerHeight;
            updateSceneAndContent();
        }

        // Handle wheel event for section-by-section scrolling
        function onWheel(event) {
            event.preventDefault(); // Prevent default scroll behavior
            if (isAnimating) return;

            const direction = Math.sign(event.deltaY);

            if (direction > 0) {
                // Scrolling down
                if (currentSectionIndex < contentSections.length - 1) {
                    currentSectionIndex++;
                    scrollToSection(currentSectionIndex);
                }
            } else {
                // Scrolling up
                if (currentSectionIndex > 0) {
                    currentSectionIndex--;
                    scrollToSection(currentSectionIndex);
                }
            }
        }

        // Handle touch start event for mobile
        function onTouchStart(event) {
            event.preventDefault();
            touchStartY = event.touches[0].clientY;
        }

        // Handle touch end event for mobile
        function onTouchEnd(event) {
            if (isAnimating) return;

            const touchEndY = event.changedTouches[0].clientY;
            const deltaY = touchEndY - touchStartY;
            const swipeThreshold = 50; // Minimum distance for a swipe

            if (deltaY < -swipeThreshold) { // Swipe up
                if (currentSectionIndex < contentSections.length - 1) {
                    currentSectionIndex++;
                    scrollToSection(currentSectionIndex);
                }
            } else if (deltaY > swipeThreshold) { // Swipe down
                if (currentSectionIndex > 0) {
                    currentSectionIndex--;
                    scrollToSection(currentSectionIndex);
                }
            }
        }

        // Animate scrolling to a specific section
        function scrollToSection(index) {
            isAnimating = true;
            const targetScrollTop = index * window.innerHeight;
            const startScrollTop = scrollContainer.scrollTop;
            const distance = targetScrollTop - startScrollTop;
            const duration = 2200; // Animation duration in ms (faster traverse)
            let startTime = null;

            function animateScroll(currentTime) {
                if (startTime === null) startTime = currentTime;
                const elapsedTime = currentTime - startTime;
                const progress = Math.min(elapsedTime / duration, 1);

                // Easing function for smoother animation
                const easedProgress = 0.5 - 0.5 * Math.cos(progress * Math.PI);
                scrollContainer.scrollTop = startScrollTop + distance * easedProgress;

                updateSceneAndContent();

                if (progress < 1) {
                    requestAnimationFrame(animateScroll);
                } else {
                    isAnimating = false;
                }
            }

            requestAnimationFrame(animateScroll);
        }

        // Animate camera along the tunnel based on scroll position only
        function animate() {
            requestAnimationFrame(animate);

            // Animate debris (leaves and branches)
            debrisMeshes.forEach(mesh => {
                mesh.rotation.x += 0.001 + Math.random() * 0.001;
                mesh.rotation.y += 0.001 + Math.random() * 0.001;
                // Gentle floating motion
                mesh.position.y += Math.sin(Date.now() * 0.0005 + mesh.id) * 0.005;
            });

            // Update particles for twinkling and movement
            if (particles) {
                const positions = particles.geometry.attributes.position.array;
                for (let i = 0; i < positions.length; i += 3) {
                    positions[i] += particleVelocities[i / 3].x;
                    positions[i + 1] += particleVelocities[i / 3].y;
                    positions[i + 2] += particleVelocities[i / 3].z;

                    // If particle goes off-screen, reset its position
                    if (positions[i] > 75 || positions[i] < -75) positions[i] = (Math.random() - 0.5) * 150;
                    if (positions[i + 1] > 75 || positions[i + 1] < -75) positions[i + 1] = (Math.random() - 0.5) * 150;
                    if (positions[i + 2] > 75 || positions[i + 2] < -75) positions[i + 2] = (Math.random() - 0.5) * 150;
                }
                particles.geometry.attributes.position.needsUpdate = true;

                // Twinkle effect
                particles.material.opacity = 0.5 + 0.25 * Math.sin(Date.now() * 0.002);
            }

            // Only update scene based on scroll position, not auto-progress
            updateSceneAndContent();
            renderer.render(scene, camera);
        }

        // Get scroll progress (0 to 1) based on scrollContainer
        function getScrollProgress() {
            const scrollTop = scrollContainer.scrollTop;
            const maxScroll = scrollContentWrapper.scrollHeight - window.innerHeight;
            return maxScroll > 0 ? scrollTop / maxScroll : 0;
        }

        // Update camera and scene based on scroll progress
        function updateSceneAndContent() {
            const progress = getScrollProgress();
            // Stop the camera just before the end of the tunnel to keep the exit in view
            const clampedProgress = Math.max(0, Math.min(0.95, progress));
            const cameraPoint = curve.getPointAt(clampedProgress);
            const cameraTangent = curve.getTangentAt(clampedProgress).normalize();
            camera.position.copy(cameraPoint);
            const lookAtPoint = cameraPoint.clone().add(cameraTangent.multiplyScalar(0.1));
            camera.lookAt(lookAtPoint);
            pointLight.position.copy(cameraPoint);

            // Fade in the end-of-tunnel light as the user approaches the last section
            const endLightIntensity = Math.max(0, (clampedProgress - 0.8) / 0.2) * 10; // Brighter light at the end
            endOfTunnelLight.intensity = endLightIntensity;

            // Animate section visibility and scale based on scroll progress
            const sectionScrollProgress = progress * (contentSections.length - 1);
            contentSections.forEach((section, index) => {
                const distance = Math.abs(index - sectionScrollProgress);
                const opacity = Math.max(0, 1 - distance);
                const scale = 0.5 + 0.5 * Math.max(0, 1 - distance);

                // Revert the last section to behave like the others
                section.style.position = 'relative'; // Revert position
                section.style.opacity = opacity;
                section.style.transform = `scale(${scale})`;
                section.style.color = 'white';
            });
        }

        // This function is no longer needed as its logic is merged into updateSceneAndContent
        // function positionLastSectionInsideTunnel() { ... }

        // Ensure the end of the tunnel has a proper circular cap
        function addTunnelEndCap() {
            const endPoint = curve.getPointAt(1); // Get the last point of the curve
            const tangent = curve.getTangentAt(1).normalize();
            const endCapGeom = new THREE.CircleGeometry(tubeRadius, 32); // Circular geometry for the end cap, matching tubeRadius
            const endCapMat = new THREE.MeshPhysicalMaterial({
                color: 0x0A0A0A, // Match the tunnel wall color
                roughness: 0.95,
                metalness: 0.05,
                opacity: 0.65,
                transparent: true,
                side: THREE.DoubleSide
            });
            const endCap = new THREE.Mesh(endCapGeom, endCapMat);
            endCap.position.copy(endPoint);
            endCap.quaternion.setFromUnitVectors(new THREE.Vector3(0, 0, 1), tangent);
            scene.add(endCap);
        }

        // Initialize Three.js and start the animation when the window loads
        window.onload = function() {
            setViewportHeight();
            initThree();
            addTunnelEndCap(); // Ensure the end cap is added
            // positionLastSectionInsideTunnel(); // This is now handled in the update loop
            animate();
        };
    </script>
</body>
</html>
