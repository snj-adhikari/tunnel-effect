<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tube Website Experience</title>
    <!-- Tailwind CSS CDN for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Inter font from Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        /* Custom CSS for the page */

        .section-content {
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            text-align: center;
            max-width: 80%; /* Limit the width to 80% of the screen */
            width: 100%; /* Ensure it takes full width up to the max-width */
            height: calc(var(--vh, 1vh) * 100); /* Use dynamic viewport height for mobile */
            background: transparent;
            margin: 0 auto; /* Center horizontally */
            padding: 1rem; /* Add some padding for better responsiveness */
            box-sizing: border-box; /* Include padding in width calculations */
            opacity: 0; /* Initially hidden */
            transform: scale(0.5); /* Start scaled down for the traverse effect */
            transition: opacity 0.5s ease-in-out, transform 0.5s ease-in-out; /* Animate opacity and scale */
        }

        /* Ensure the scrollable content extends beyond the viewport to enable scrolling */
        #scroll-content-wrapper {
            /* This height will be dynamically set by JS to enable scrolling */
            min-height: 100vh; /* Minimum height, will be adjusted */
        }

        #three-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1; /* Below content overlay */
        }

        #scroll-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            overflow-y: hidden; /* Disable the native scrollbar */
            z-index: 2; /* Above Three.js canvas */
        }
    </style>
</head>
<body>
    <!-- Container for the Three.js canvas -->
    <div id="three-container"></div>

    <!-- Scrollable container for the HTML content overlay -->
    <div id="scroll-container">
        <div id="scroll-content-wrapper">
            <!-- Sample Content Sections -->
            <section id="section1" class="section-content" data-scroll-start="0" data-scroll-end="0.2">
                <h1 class="text-5xl md:text-7xl font-bold mb-4">Welcome to the Tube Journey!</h1>
                <p class="text-lg md:text-xl max-w-2xl">
                    Explore our immersive experience as you traverse through a mystical tube.
                    Scroll down to begin your adventure.
                </p>
                <button class="mt-8 px-6 py-3 bg-blue-600 hover:bg-blue-700 text-white font-semibold rounded-full shadow-lg transition duration-300">
                    Start Exploring
                </button>
            </section>

            <section id="section2" class="section-content" data-scroll-start="0.2" data-scroll-end="0.4">
                <h2 class="text-4xl md:text-6xl font-bold mb-4">Our Mission</h2>
                <p class="text-lg md:text-xl max-w-2xl">
                    We aim to redefine web navigation by blending stunning visuals with seamless interaction.
                    Each twist and turn reveals new insights.
                </p>
                <div class="mt-8 grid grid-cols-1 md:grid-cols-3 gap-6">
                    <div class="bg-gray-800 p-6 rounded-lg shadow-md">
                        <h3 class="text-2xl font-semibold mb-2">Innovation</h3>
                        <p>Pushing the boundaries of web design.</p>
                    </div>
                    <div class="bg-gray-800 p-6 rounded-lg shadow-md">
                        <h3 class="text-2xl font-semibold mb-2">Experience</h3>
                        <p>Crafting unforgettable user journeys.</p>
                    </div>
                    <div class="bg-gray-800 p-6 rounded-lg shadow-md">
                        <h3 class="text-2xl font-semibold mb-2">Simplicity</h3>
                        <p>Complex ideas, elegantly presented.</p>
                    </div>
                </div>
            </section>

            <section id="section3" class="section-content" data-scroll-start="0.4" data-scroll-end="0.6">
                <h2 class="text-4xl md:text-6xl font-bold mb-4">What You'll Discover</h2>
                <p class="text-lg md:text-xl max-w-2xl">
                    From captivating articles to interactive elements, every segment of the tube holds a surprise.
                    Prepare to be amazed!
                </p>
                <ul class="mt-8 text-left space-y-4 text-lg md:text-xl">
                    <li>âœ¨ Immersive Visuals</li>
                    <li>ðŸš€ Seamless Navigation</li>
                    <li>ðŸ’¡ Engaging Content</li>
                    <li>ðŸ”’ Secure Environment</li>
                </ul>
            </section>

            <section id="section4" class="section-content" data-scroll-start="0.6" data-scroll-end="0.8">
                <h2 class="text-4xl md:text-6xl font-bold mb-4">Get Started</h2>
                <p class="text-lg md:text-xl max-w-2xl">
                    Ready to embark on your own journey? Join our community and start creating!
                </p>
                <form class="mt-8 w-full max-w-md bg-gray-800 p-8 rounded-lg shadow-md">
                    <div class="mb-4">
                        <label for="name" class="block text-white text-sm font-bold mb-2">Name:</label>
                        <input type="text" id="name" name="name" class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline" placeholder="Your Name">
                    </div>
                    <div class="mb-6">
                        <label for="email" class="block text-white text-sm font-bold mb-2">Email:</label>
                        <input type="email" id="email" name="email" class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 mb-3 leading-tight focus:outline-none focus:shadow-outline" placeholder="your@example.com">
                    </div>
                    <button type="submit" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-full focus:outline-none focus:shadow-outline transition duration-300">
                        Sign Up
                    </button>
                </form>
            </section>

            <section id="section5" class="section-content" data-scroll-start="0.56" data-scroll-end="0.70">
                <h2 class="text-4xl md:text-6xl font-bold mb-4">Contact Us</h2>
                <p class="text-lg md:text-xl max-w-2xl">
                    Have questions or feedback? We'd love to hear from you.
                </p>
                <div class="mt-8 flex flex-col md:flex-row gap-6">
                    <a href="#" class="px-6 py-3 bg-purple-600 hover:bg-purple-700 text-white font-semibold rounded-full shadow-lg transition duration-300">
                        Email Us
                    </a>
                    <a href="#" class="px-6 py-3 bg-red-600 hover:bg-red-700 text-white font-semibold rounded-full shadow-lg transition duration-300">
                        Follow on X
                    </a>
                </div>
            </section>

            <section id="section6" class="section-content" data-scroll-start="0.70" data-scroll-end="0.84">
                <h2 class="text-4xl md:text-6xl font-bold mb-4">Our Community</h2>
                <p class="text-lg md:text-xl max-w-2xl">
                    Join a vibrant community of creators and innovators.
                </p>
            </section>

            <section id="section7" class="section-content" data-scroll-start="0.84" data-scroll-end="1.0">
                <h2 class="text-4xl md:text-6xl font-bold mb-4">The End of the Line</h2>
                <p class="text-lg md:text-xl max-w-2xl">
                    You\'ve reached the destination, but the journey never truly ends.
                </p>
            </section>
        </div>
    </div>

    <!-- Three.js CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script>
        // Three.js variables
        let scene, camera, renderer, tubeMesh, curve, pointLight;
        let scrollContainer, scrollContentWrapper, contentSections;
        let currentSectionIndex = 0;
        let isAnimating = false; // To prevent scroll spam
        let touchStartY = 0; // For mobile touch events
        let particles, particleVelocities; // For moving particles
        let endOfTunnelLight; // Light at the end of the tunnel
        let debrisMeshes = []; // To store and animate debris
        let rockModel; // To store the loaded rock model
        let rockMeshes = []; // This will now store the InstancedMesh objects
        let externalModel; // To store the loaded external model

        // Function to set the viewport height dynamically for mobile
        function setViewportHeight() {
            const vh = window.innerHeight * 0.01;
            document.documentElement.style.setProperty('--vh', `${vh}px`);
        }

        // Function to create a procedural rock texture for realism
        function createRockTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const context = canvas.getContext('2d');

            // Base rock color
            context.fillStyle = '#4a4a4a';
            context.fillRect(0, 0, 256, 256);

            // Add noise for texture and depth
            for (let i = 0; i < 15000; i++) {
                const x = Math.random() * 256;
                const y = Math.random() * 256;
                const color = Math.random() * 40 + 20; // Dark gray noise
                context.fillStyle = `rgb(${color},${color},${color})`;
                context.fillRect(x, y, 2, 2);
            }

            // Add lighter and darker patches for more variation
            for (let i = 0; i < 80; i++) {
                const x = Math.random() * 256;
                const y = Math.random() * 256;
                const size = Math.random() * 40 + 15;
                const gradient = context.createRadialGradient(x, y, 0, x, y, size);
                if (Math.random() > 0.5) {
                    gradient.addColorStop(0, 'rgba(120, 120, 120, 0.25)');
                    gradient.addColorStop(1, 'rgba(120, 120, 120, 0)');
                } else {
                    gradient.addColorStop(0, 'rgba(0, 0, 0, 0.2)');
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                }
                context.fillStyle = gradient;
                context.fillRect(0, 0, 256, 256);
            }

            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.needsUpdate = true;
            return texture;
        }

        // Create realistic tunnel using multiple InstancedMesh for performance and variety
        function createRealisticTunnel() {
            console.log('Creating high-performance, realistic tunnel with textures...');

            const geometries = [
                new THREE.DodecahedronGeometry(1.2, 0),
                new THREE.IcosahedronGeometry(1.5, 0),
                new THREE.BoxGeometry(1.8, 1.8, 1.8)
            ];

            geometries.forEach(geometry => {
                const vertices = geometry.attributes.position.array;
                for (let i = 0; i < vertices.length; i += 3) {
                    vertices[i] += (Math.random() - 0.5) * 0.8;
                    vertices[i + 1] += (Math.random() - 0.5) * 0.8;
                    vertices[i + 2] += (Math.random() - 0.5) * 0.8;
                }
                geometry.computeVertexNormals();
            });

            const rockTexture = createRockTexture();

            const material = new THREE.MeshStandardMaterial({
                map: rockTexture, // Apply the procedural texture
                bumpMap: rockTexture, // Use the same texture for bump mapping for depth
                bumpScale: 0.05, // Adjust the bumpiness
                roughness: 0.95, // Very rough surface
                metalness: 0.1,
            });

            const instancesPerGeometry = 800; // Slightly fewer instances for performance
            const dummy = new THREE.Object3D();

            geometries.forEach(geometry => {
                const instancedMesh = new THREE.InstancedMesh(geometry, material, instancesPerGeometry);
                instancedMesh.castShadow = true;
                instancedMesh.receiveShadow = true;

                for (let i = 0; i < instancesPerGeometry; i++) {
                    const t = Math.random();
                    const pos = curve.getPointAt(t);
                    const angle = Math.random() * Math.PI * 2;
                    const radius = 8 + Math.random() * 10; // Adjusted radius for the new curve

                    dummy.position.set(
                        pos.x + Math.cos(angle) * radius + (Math.random() - 0.5) * 3,
                        pos.y + Math.sin(angle) * radius + (Math.random() - 0.5) * 3,
                        pos.z + (Math.random() - 0.5) * 12 // Scatter along the z-axis
                    );

                    const scale = 0.8 + Math.random() * 2.5; // Increase max scale for more variety
                    dummy.scale.set(scale, scale, scale);

                    dummy.rotation.set(
                        Math.random() * Math.PI * 2,
                        Math.random() * Math.PI * 2,
                        Math.random() * Math.PI * 2
                    );

                    dummy.updateMatrix();
                    instancedMesh.setMatrixAt(i, dummy.matrix);
                }
                scene.add(instancedMesh);
                rockMeshes.push(instancedMesh);
            });

            console.log('Textured and realistic instanced tunnel created successfully.');
        }

        // Load external 3D model from free CDN
        function loadExternalModel() {
            console.log('Loading external 3D model...');
            const loader = new THREE.GLTFLoader();
            const modelUrl = 'https://cdn.jsdelivr.net/gh/mrdoob/three.js/examples/models/gltf/PrimaryIonDrive.glb';

            loader.load(modelUrl, (gltf) => {
                externalModel = gltf.scene;
                externalModel.scale.set(2.5, 2.5, 2.5); // Slightly increase model size
                // Position the model in the center of the main loop of the new curve
                externalModel.position.set(0, 0, -100);
                externalModel.rotation.y = -Math.PI / 2; // Rotate to face the camera at the start

                externalModel.traverse(function(child) {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                        // Optional: Add emissive material for glowing effect
                        child.material.emissive = new THREE.Color(0x00ff00);
                        child.material.emissiveIntensity = 0.8;
                    }
                });

                scene.add(externalModel);
                console.log('External model loaded and positioned at the center of the curve.');
            }, undefined, (error) => {
                console.error('An error occurred while loading the model:', error);
            });
        }

        // Function to create a glowing line texture
        function createLineTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 128; // Texture width
            canvas.height = 128; // Texture height
            const context = canvas.getContext('2d');

            // Draw a black background
            context.fillStyle = '#000000';
            context.fillRect(0, 0, canvas.width, canvas.height);

            // Draw white vertical lines
            context.strokeStyle = '#FFFFFF'; // White lines
            context.lineWidth = 2; // Line thickness
            const lineSpacing = 16; // Space between lines

            for (let x = 0; x < canvas.width; x += lineSpacing) {
                context.beginPath();
                context.moveTo(x, 0);
                context.lineTo(x, canvas.height);
                context.stroke();
            }

            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            return texture;
        }

        // Add particles to the background
        function addParticles() {
            const particleCount = 1200; // Increased particle count for denser feel
            const particleGeometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            particleVelocities = [];

            for (let i = 0; i < particleCount; i++) {
                positions[i * 3] = (Math.random() - 0.5) * 150;
                positions[i * 3 + 1] = (Math.random() - 0.5) * 150;
                positions[i * 3 + 2] = (Math.random() - 0.5) * 150;
                particleVelocities.push(new THREE.Vector3(
                    (Math.random() - 0.5) * 0.03,
                    (Math.random() - 0.5) * 0.03,
                    (Math.random() - 0.5) * 0.03
                ));
            }
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

            const particleMaterial = new THREE.PointsMaterial({
                color: 0x8B4513, // Dirt/saddle brown color
                size: 0.2, // Slightly larger particles
                transparent: true,
                opacity: 0.6,
                blending: THREE.AdditiveBlending
            });

            particles = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(particles);
        }

        // Function to create a realistic leaf mesh with a crease
        function createLeafMesh() {
            const leafShape = new THREE.Shape();
            // Define the leaf outline with a crease
            leafShape.moveTo(0, 0);
            leafShape.quadraticCurveTo(0.1, 0.1, 0.2, 0.4);
            leafShape.quadraticCurveTo(0.05, 0.6, 0, 0.8); // Tip
            leafShape.quadraticCurveTo(-0.05, 0.6, -0.2, 0.4);
            leafShape.quadraticCurveTo(-0.1, 0.1, 0, 0); // Back to base

            const extrudeSettings = {
                steps: 1,
                depth: 0.02,
                bevelEnabled: true,
                bevelThickness: 0.01,
                bevelSize: 0.01,
                bevelSegments: 1
            };

            const leafGeom = new THREE.ExtrudeGeometry(leafShape, extrudeSettings);
            const leafMat = new THREE.MeshPhysicalMaterial({
                color: 0x556B2F, // Darker, more realistic green
                roughness: 0.8,
                side: THREE.DoubleSide,
                transmission: 0.4,
                opacity: 0.9,
                transparent: true
            });
            const leaf = new THREE.Mesh(leafGeom, leafMat);
            leaf.castShadow = true;
            return leaf;
        }

        // Function to create a realistic, multi-part branch mesh with leaves
        function createBranchMesh() {
            const branchGroup = new THREE.Group();
            const branchMat = new THREE.MeshPhysicalMaterial({
                color: 0x3C2A1E, // Darker, more realistic brown
                roughness: 0.9,
                metalness: 0.1
            });

            // Main branch
            const mainGeom = new THREE.CylinderGeometry(0.08, 0.12, 4, 8);
            const mainBranch = new THREE.Mesh(mainGeom, branchMat);
            mainBranch.castShadow = true;
            branchGroup.add(mainBranch);

            // Add smaller sub-branches and leaves
            const subBranchCount = 2 + Math.floor(Math.random() * 2);
            for (let i = 0; i < subBranchCount; i++) {
                const subGeom = new THREE.CylinderGeometry(0.04, 0.06, 2, 6);
                const subBranch = new THREE.Mesh(subGeom, branchMat);
                subBranch.position.y = (Math.random() - 0.5) * 1.5;
                subBranch.position.x = (Math.random() - 0.5) * 0.2;
                subBranch.rotation.z = (Math.random() - 0.5) * Math.PI / 2;
                subBranch.rotation.x = (Math.random() - 0.5) * Math.PI / 2;
                subBranch.castShadow = true;
                mainBranch.add(subBranch);

                // Add a leaf to the sub-branch
                if (Math.random() > 0.3) {
                    const leaf = createLeafMesh();
                    const leafScale = 0.5 + Math.random() * 0.5;
                    leaf.scale.set(leafScale, leafScale, leafScale);
                    leaf.position.y = 1; // Tip of the sub-branch
                    leaf.rotation.x = Math.PI / 2;
                    subBranch.add(leaf);
                }
            }

            return branchGroup;
        }

        // Function to add random 3D debris like leaves and branches
        function addRandomDebris(curve, count) {
            for (let i = 0; i < count; i++) {
                const t = Math.random();
                const pos = curve.getPointAt(t);
                const tangent = curve.getTangentAt(t);

                let object;
                let scale = 0.8 + Math.random() * 0.4; // Randomize scale

                // Randomly decide to create a leaf or a branch
                if (Math.random() > 0.6) {
                    // Create a realistic leaf
                    object = createLeafMesh();
                } else {
                    // Create a realistic branch
                    object = createBranchMesh();
                    scale *= 0.8; // Branches are a bit smaller overall
                }

                object.scale.set(scale, scale, scale);
                object.position.copy(pos);
                object.position.add(new THREE.Vector3(
                    (Math.random() - 0.5) * 18,
                    (Math.random() - 0.5) * 18,
                    (Math.random() - 0.5) * 18
                ));
                object.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), tangent);
                object.rotation.x += Math.random() * Math.PI;
                object.rotation.z += Math.random() * Math.PI;
                scene.add(object);
                debrisMeshes.push(object); // Store debris for animation
            }
        }

        // Initialize and animate the Three.js scene
        function initThree() {
            // Scene setup
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x1a1a1a, 5, 40); // Closer fog for depth perception

            // Camera setup with better FOV for 3D depth
            camera = new THREE.PerspectiveCamera(85, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 0);

            // Renderer setup with enhanced settings for 3D
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setClearColor(0x000000, 1);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2; // Adjusted exposure
            document.getElementById('three-container').appendChild(renderer.domElement);

            // Create enhanced 3D curve
            createCurve();

            // Optimized lighting setup for performance and realism
            const ambientLight = new THREE.AmbientLight(0x404040, 0.8); // A bit brighter ambient
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
            directionalLight.position.set(10, 15, 5); // Repositioned for better highlights
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 1024; // Standard shadow map size
            directionalLight.shadow.mapSize.height = 1024;
            scene.add(directionalLight);

            // Moving point light for dynamic 3D shadows
            pointLight = new THREE.PointLight(0xffffff, 1.2, 40); // Adjusted intensity and distance
            pointLight.castShadow = true;
            scene.add(pointLight);

            // End light
            endOfTunnelLight = new THREE.PointLight(0xffffff, 5, 50);
            endOfTunnelLight.position.copy(curve.getPointAt(1));
            scene.add(endOfTunnelLight);

            // Load external model or create procedural tunnel
            loadExternalModel();

            // Keep some traditional elements for depth
            addRandomDebris(curve, 30); // Reduced debris count since we have rocks now

            // Get HTML elements
            scrollContainer = document.getElementById('scroll-container');
            scrollContentWrapper = document.getElementById('scroll-content-wrapper');
            contentSections = document.querySelectorAll('.section-content');

            // Set the scrollable height to enable snapping between sections
            scrollContentWrapper.style.height = `${contentSections.length * 100}vh`;

            // Initial update of camera and content positions
            updateSceneAndContent();

            // Event listeners
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('wheel', onWheel, { passive: false }); // Use wheel event for controlled scrolling
            window.addEventListener('touchstart', onTouchStart, { passive: false });
            window.addEventListener('touchend', onTouchEnd, { passive: false });

            addParticles();

            // Debugging logs to identify issues
            console.log('Initializing Three.js with realistic 3D tunnel...');
        }

        // Create the main 3D curve for the camera path, now with more 3D traversal
        function createCurve() {
            console.log('Creating a more dynamic 3D curve...');
            const points = [];
            const numPoints = 150;
            const radius = 25; // Radius of the main loop
            const verticalFluctuation = 15; // How much the path moves up and down

            for (let i = 0; i < numPoints; i++) {
                const angle = (i / numPoints) * Math.PI * 4; // Two full circles
                const x = Math.cos(angle) * radius;
                // Create a path that weaves up and down for a more 3D feel
                const y = Math.sin(angle * 2) * verticalFluctuation;
                const z = Math.sin(angle) * radius;
                points.push(new THREE.Vector3(x, y, z - 100)); // Move the whole path back
            }

            // Add a final straight section to avoid a sharp loop at the end
            const lastPoint = points[points.length - 1].clone();
            for (let i = 1; i <= 10; i++) {
                points.push(new THREE.Vector3(lastPoint.x, lastPoint.y, lastPoint.z + i * 20));
            }

            curve = new THREE.CatmullRomCurve3(points, false, 'catmullrom', 0.5);
            console.log('Dynamic 3D curve created.');
        }

        // Handle window resize
        function onWindowResize() {
            setViewportHeight(); // Adjust height on resize
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);

            // Re-adjust scrollable height on resize
            scrollContentWrapper.style.height = `${contentSections.length * 100}vh`;

            // Snap to the current section's position after resize
            scrollContainer.scrollTop = currentSectionIndex * window.innerHeight;
            updateSceneAndContent();
        }

        // Handle wheel event for section-by-section scrolling
        function onWheel(event) {
            event.preventDefault(); // Prevent default scroll behavior
            if (isAnimating) return;

            const direction = Math.sign(event.deltaY);

            if (direction > 0) {
                // Scrolling down
                if (currentSectionIndex < contentSections.length - 1) {
                    currentSectionIndex++;
                    scrollToSection(currentSectionIndex);
                }
            } else {
                // Scrolling up
                if (currentSectionIndex > 0) {
                    currentSectionIndex--;
                    scrollToSection(currentSectionIndex);
                }
            }
        }

        // Handle touch start event for mobile
        function onTouchStart(event) {
            event.preventDefault();
            touchStartY = event.touches[0].clientY;
        }

        // Handle touch end event for mobile
        function onTouchEnd(event) {
            if (isAnimating) return;

            const touchEndY = event.changedTouches[0].clientY;
            const deltaY = touchEndY - touchStartY;
            const swipeThreshold = 50; // Minimum distance for a swipe

            if (deltaY < -swipeThreshold) { // Swipe up
                if (currentSectionIndex < contentSections.length - 1) {
                    currentSectionIndex++;
                    scrollToSection(currentSectionIndex);
                }
            } else if (deltaY > swipeThreshold) { // Swipe down
                if (currentSectionIndex > 0) {
                    currentSectionIndex--;
                    scrollToSection(currentSectionIndex);
                }
            }
        }

        // Animate scrolling to a specific section
        function scrollToSection(index) {
            isAnimating = true;
            const targetScrollTop = index * window.innerHeight;
            const startScrollTop = scrollContainer.scrollTop;
            const distance = targetScrollTop - startScrollTop;
            const duration = 2200; // Animation duration in ms (faster traverse)
            let startTime = null;

            function animateScroll(currentTime) {
                if (startTime === null) startTime = currentTime;
                const elapsedTime = currentTime - startTime;
                const progress = Math.min(elapsedTime / duration, 1);

                // Easing function for smoother animation
                const easedProgress = 0.5 - 0.5 * Math.cos(progress * Math.PI);
                scrollContainer.scrollTop = startScrollTop + distance * easedProgress;

                updateSceneAndContent();

                if (progress < 1) {
                    requestAnimationFrame(animateScroll);
                } else {
                    isAnimating = false;
                }
            }

            requestAnimationFrame(animateScroll);
        }

        // Animate camera along the tunnel based on scroll position only
        function animate() {
            requestAnimationFrame(animate);

            // Animate debris (leaves and branches)
            debrisMeshes.forEach(mesh => {
                mesh.rotation.x += 0.001 + Math.random() * 0.001;
                mesh.rotation.y += 0.001 + Math.random() * 0.001;
                // Gentle floating motion
                mesh.position.y += Math.sin(Date.now() * 0.0005 + mesh.id) * 0.005;
            });

            // The rock animation was removed as it's not needed for InstancedMesh and was causing issues.
            // The rocks are now static for realism and performance.

            // Update particles for twinkling and movement
            if (particles) {
                const positions = particles.geometry.attributes.position.array;
                for (let i = 0; i < positions.length; i += 3) {
                    positions[i] += particleVelocities[i / 3].x;
                    positions[i + 1] += particleVelocities[i / 3].y;
                    positions[i + 2] += particleVelocities[i / 3].z;

                    // If particle goes off-screen, reset its position
                    if (positions[i] > 75 || positions[i] < -75) positions[i] = (Math.random() - 0.5) * 150;
                    if (positions[i + 1] > 75 || positions[i + 1] < -75) positions[i + 1] = (Math.random() - 0.5) * 150;
                    if (positions[i + 2] > 75 || positions[i + 2] < -75) positions[i + 2] = (Math.random() - 0.5) * 150;
                }
                particles.geometry.attributes.position.needsUpdate = true;

                // Twinkle effect
                particles.material.opacity = 0.5 + 0.25 * Math.sin(Date.now() * 0.002);
            }

            // Only update scene based on scroll position, not auto-progress
            updateSceneAndContent();
            renderer.render(scene, camera);
        }

        // Get scroll progress (0 to 1) based on scrollContainer
        function getScrollProgress() {
            const scrollTop = scrollContainer.scrollTop;
            const maxScroll = scrollContentWrapper.scrollHeight - window.innerHeight;
            return maxScroll > 0 ? scrollTop / maxScroll : 0;
        }

        // Update camera and scene based on scroll progress
        function updateSceneAndContent() {
            const progress = getScrollProgress();

            // When we are at the last section, lock the camera just before the end of the tunnel
            const cameraProgress = (currentSectionIndex === contentSections.length - 1) 
                ? (contentSections.length - 2) / (contentSections.length - 1) 
                : progress;

            const clampedProgress = Math.max(0, Math.min(1, cameraProgress));

            const cameraPoint = curve.getPointAt(clampedProgress);
            const cameraTangent = curve.getTangentAt(clampedProgress).normalize();
            camera.position.copy(cameraPoint);
            const lookAtPoint = cameraPoint.clone().add(cameraTangent.multiplyScalar(0.1));
            camera.lookAt(lookAtPoint);
            pointLight.position.copy(cameraPoint);

            // Fade in the end-of-tunnel light as the user approaches the last section
            const endLightIntensity = Math.max(0, (clampedProgress - 0.8) / 0.2) * 10; // Brighter light at the end
            endOfTunnelLight.intensity = endLightIntensity;

            // Animate section visibility and scale based on scroll progress
            const sectionScrollProgress = progress * (contentSections.length - 1);
            contentSections.forEach((section, index) => {
                const distance = Math.abs(index - sectionScrollProgress);
                const opacity = Math.max(0, 1 - distance * 1.5); // Faster fade out
                const scale = 0.5 + 0.5 * Math.max(0, 1 - distance);

                section.style.opacity = opacity;
                section.style.transform = `scale(${scale})`;
                section.style.color = 'white'; // Ensure all text is white
            });
        }

        // Initialize Three.js and start the animation when the window loads
        window.onload = function() {
            setViewportHeight();
            initThree();
            animate();
        };
    </script>
</body>
</html>
