<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tube Website Experience</title>
    <!-- Tailwind CSS CDN for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Inter font from Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        /* Custom CSS for the page */

        .section-content {
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            text-align: center;
            max-width: 80%; /* Limit the width to 80% of the screen */
            width: 100%; /* Ensure it takes full width up to the max-width */
            height: calc(var(--vh, 1vh) * 100); /* Use dynamic viewport height for mobile */
            background: transparent;
            margin: 0 auto; /* Center horizontally */
            padding: 1rem; /* Add some padding for better responsiveness */
            box-sizing: border-box; /* Include padding in width calculations */
            opacity: 0; /* Initially hidden */
            transform: scale(0.5); /* Start scaled down for the traverse effect */
            transition: opacity 0.5s ease-in-out, transform 0.5s ease-in-out; /* Animate opacity and scale */
        }

        /* Ensure the scrollable content extends beyond the viewport to enable scrolling */
        #scroll-content-wrapper {
            /* This height will be dynamically set by JS to enable scrolling */
            min-height: 100vh; /* Minimum height, will be adjusted */
        }

        #three-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1; /* Below content overlay */
        }

        #scroll-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            overflow-y: hidden; /* Disable the native scrollbar */
            z-index: 2; /* Above Three.js canvas */
        }
    </style>
</head>
<body>
    <!-- Container for the Three.js canvas -->
    <div id="three-container"></div>

    <!-- Scrollable container for the HTML content overlay -->
    <div id="scroll-container">
        <div id="scroll-content-wrapper">
            <!-- Sample Content Sections -->
            <section id="section1" class="section-content" data-scroll-start="0" data-scroll-end="0.2">
                <h1 class="text-5xl md:text-7xl font-bold mb-4">Welcome to the Tube Journey!</h1>
                <p class="text-lg md:text-xl max-w-2xl">
                    Explore our immersive experience as you traverse through a mystical tube.
                    Scroll down to begin your adventure.
                </p>
                <button class="mt-8 px-6 py-3 bg-blue-600 hover:bg-blue-700 text-white font-semibold rounded-full shadow-lg transition duration-300">
                    Start Exploring
                </button>
            </section>

            <section id="section2" class="section-content" data-scroll-start="0.2" data-scroll-end="0.4">
                <h2 class="text-4xl md:text-6xl font-bold mb-4">Our Mission</h2>
                <p class="text-lg md:text-xl max-w-2xl">
                    We aim to redefine web navigation by blending stunning visuals with seamless interaction.
                    Each twist and turn reveals new insights.
                </p>
                <div class="mt-8 grid grid-cols-1 md:grid-cols-3 gap-6">
                    <div class="bg-gray-800 p-6 rounded-lg shadow-md">
                        <h3 class="text-2xl font-semibold mb-2">Innovation</h3>
                        <p>Pushing the boundaries of web design.</p>
                    </div>
                    <div class="bg-gray-800 p-6 rounded-lg shadow-md">
                        <h3 class="text-2xl font-semibold mb-2">Experience</h3>
                        <p>Crafting unforgettable user journeys.</p>
                    </div>
                    <div class="bg-gray-800 p-6 rounded-lg shadow-md">
                        <h3 class="text-2xl font-semibold mb-2">Simplicity</h3>
                        <p>Complex ideas, elegantly presented.</p>
                    </div>
                </div>
            </section>

            <section id="section3" class="section-content" data-scroll-start="0.4" data-scroll-end="0.6">
                <h2 class="text-4xl md:text-6xl font-bold mb-4">What You'll Discover</h2>
                <p class="text-lg md:text-xl max-w-2xl">
                    From captivating articles to interactive elements, every segment of the tube holds a surprise.
                    Prepare to be amazed!
                </p>
                <ul class="mt-8 text-left space-y-4 text-lg md:text-xl">
                    <li>âœ¨ Immersive Visuals</li>
                    <li>ðŸš€ Seamless Navigation</li>
                    <li>ðŸ’¡ Engaging Content</li>
                    <li>ðŸ”’ Secure Environment</li>
                </ul>
            </section>

            <section id="section4" class="section-content" data-scroll-start="0.6" data-scroll-end="0.8">
                <h2 class="text-4xl md:text-6xl font-bold mb-4">Get Started</h2>
                <p class="text-lg md:text-xl max-w-2xl">
                    Ready to embark on your own journey? Join our community and start creating!
                </p>
                <form class="mt-8 w-full max-w-md bg-gray-800 p-8 rounded-lg shadow-md">
                    <div class="mb-4">
                        <label for="name" class="block text-white text-sm font-bold mb-2">Name:</label>
                        <input type="text" id="name" name="name" class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline" placeholder="Your Name">
                    </div>
                    <div class="mb-6">
                        <label for="email" class="block text-white text-sm font-bold mb-2">Email:</label>
                        <input type="email" id="email" name="email" class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 mb-3 leading-tight focus:outline-none focus:shadow-outline" placeholder="your@example.com">
                    </div>
                    <button type="submit" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-full focus:outline-none focus:shadow-outline transition duration-300">
                        Sign Up
                    </button>
                </form>
            </section>

            <section id="section5" class="section-content" data-scroll-start="0.8" data-scroll-end="1.0">
                <h2 class="text-4xl md:text-6xl font-bold mb-4">Contact Us</h2>
                <p class="text-lg md:text-xl max-w-2xl">
                    Have questions or feedback? We'd love to hear from you.
                </p>
                <div class="mt-8 flex flex-col md:flex-row gap-6">
                    <a href="#" class="px-6 py-3 bg-purple-600 hover:bg-purple-700 text-white font-semibold rounded-full shadow-lg transition duration-300">
                        Email Us
                    </a>
                    <a href="#" class="px-6 py-3 bg-red-600 hover:bg-red-700 text-white font-semibold rounded-full shadow-lg transition duration-300">
                        Follow on X
                    </a>
                </div>
            </section>
        </div>
    </div>

    <!-- Three.js CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Three.js variables
        let scene, camera, renderer, tubeMesh, curve, pointLight;
        let scrollContainer, scrollContentWrapper, contentSections;
        let currentSectionIndex = 0;
        let isAnimating = false; // To prevent scroll spam
        let touchStartY = 0; // For mobile touch events

        // Function to set the viewport height dynamically for mobile
        function setViewportHeight() {
            const vh = window.innerHeight * 0.01;
            document.documentElement.style.setProperty('--vh', `${vh}px`);
        }

        // Function to create a glowing line texture
        function createLineTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 128; // Texture width
            canvas.height = 128; // Texture height
            const context = canvas.getContext('2d');

            // Draw a black background
            context.fillStyle = '#000000';
            context.fillRect(0, 0, canvas.width, canvas.height);

            // Draw white vertical lines
            context.strokeStyle = '#FFFFFF'; // White lines
            context.lineWidth = 2; // Line thickness
            const lineSpacing = 16; // Space between lines

            for (let x = 0; x < canvas.width; x += lineSpacing) {
                context.beginPath();
                context.moveTo(x, 0);
                context.lineTo(x, canvas.height);
                context.stroke();
            }

            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            return texture;
        }

        // Add particles to the background
        function addParticles() {
            const particleCount = 500;
            const particleGeometry = new THREE.BufferGeometry();
            const particleMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.1,
                transparent: true,
                opacity: 0.8
            });

            const positions = new Float32Array(particleCount * 3);
            for (let i = 0; i < particleCount; i++) {
                positions[i * 3] = (Math.random() - 0.5) * 100;
                positions[i * 3 + 1] = (Math.random() - 0.5) * 100;
                positions[i * 3 + 2] = (Math.random() - 0.5) * 100;
            }

            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const particles = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(particles);
        }

        // Function to create a procedural bone-like normal map
        function createBoneNormalMap() {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');
            for (let y = 0; y < 256; y++) {
                for (let x = 0; x < 256; x++) {
                    // Simulate bone texture with irregular noise
                    const value = Math.floor(180 + 40 * Math.sin(x * 0.13 + y * 0.07) + 30 * Math.random());
                    ctx.fillStyle = `rgb(${value},${value},255)`;
                    ctx.fillRect(x, y, 1, 1);
                }
            }
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            return texture;
        }

        // Remove the smooth tube mesh (do not add tubeMesh to scene)
        // Instead, build the tunnel from rib arcs forming the wall
        function addSkeletonTunnel(curve, ribCount, tunnelRadius) {
            for (let i = 0; i < ribCount; i++) {
                const t = i / ribCount;
                const pos = curve.getPointAt(t);
                const tangent = curve.getTangentAt(t);
                const axis = new THREE.Vector3(0, 1, 0);
                const quaternion = new THREE.Quaternion().setFromUnitVectors(axis, tangent.clone().normalize());
                // Rib arc: a half-torus, open at the bottom
                const ribGeom = new THREE.TorusGeometry(tunnelRadius, 0.18 + Math.random() * 0.08, 16, 64, Math.PI * (1.2 + Math.random() * 0.2));
                const ribMat = new THREE.MeshPhysicalMaterial({
                    color: 0xf7e7c6,
                    roughness: 0.7,
                    metalness: 0.1,
                    transmission: 0.4,
                    thickness: 0.5,
                    ior: 1.3,
                    clearcoat: 0.3,
                    clearcoatRoughness: 0.5,
                    opacity: 0.97,
                    transparent: true
                });
                const rib = new THREE.Mesh(ribGeom, ribMat);
                rib.position.copy(pos);
                rib.quaternion.copy(quaternion);
                rib.rotation.z = Math.PI / 2 + (Math.random() - 0.5) * 0.2; // Open side down, slight random tilt
                rib.position.x += (Math.random() - 0.5) * tunnelRadius * 0.15;
                rib.position.y += (Math.random() - 0.5) * tunnelRadius * 0.1;
                scene.add(rib);
            }
        }

        // Optionally, add a central spine
        function addSpine(curve, vertebraeCount) {
            for (let i = 0; i < vertebraeCount; i++) {
                const t = i / vertebraeCount;
                const pos = curve.getPointAt(t);
                const tangent = curve.getTangentAt(t);
                const axis = new THREE.Vector3(0, 1, 0);
                const quaternion = new THREE.Quaternion().setFromUnitVectors(axis, tangent.clone().normalize());
                // Vertebra: a squashed sphere or short cylinder
                const vertebraGeom = new THREE.SphereGeometry(0.35 + Math.random() * 0.1, 16, 12);
                const vertebraMat = new THREE.MeshPhysicalMaterial({
                    color: 0xf7e7c6,
                    roughness: 0.6,
                    metalness: 0.1,
                    transmission: 0.3,
                    thickness: 0.5,
                    ior: 1.3,
                    clearcoat: 0.2,
                    clearcoatRoughness: 0.5,
                    opacity: 0.98,
                    transparent: true
                });
                const vertebra = new THREE.Mesh(vertebraGeom, vertebraMat);
                vertebra.position.copy(pos);
                vertebra.quaternion.copy(quaternion);
                vertebra.position.y -= 0.2; // Slightly below center
                scene.add(vertebra);
            }
        }

        // Remove bone/rib/spine/cocoon functions
        // Add a function to generate a 3D web tunnel made of threads
        function addWebTunnel(curve, tunnelRadius, threadCount, threadSegments) {
            for (let i = 0; i < threadCount; i++) {
                const startT = Math.random() * 0.95;
                let endT = startT + 0.05 + Math.random() * 0.2;
                if (endT > 1) endT = 1;
                const points = [];
                const spiralTurns = 2 + Math.floor(Math.random() * 3);
                for (let j = 0; j <= threadSegments; j++) {
                    let t = startT + (endT - startT) * (j / threadSegments);
                    t = Math.max(0, Math.min(1, t));
                    const base = curve.getPointAt(t);
                    const tangent = curve.getTangentAt(t).normalize();
                    let normal = new THREE.Vector3(0, 1, 0);
                    if (Math.abs(tangent.y) > 0.9) normal = new THREE.Vector3(1, 0, 0);
                    const binormal = new THREE.Vector3().crossVectors(tangent, normal).normalize();
                    normal = new THREE.Vector3().crossVectors(binormal, tangent).normalize();
                    const angle = spiralTurns * Math.PI * 2 * (j / threadSegments) + Math.random() * Math.PI * 0.2;
                    const r = tunnelRadius * (0.97 + Math.sin(angle * 2 + t * 10) * 0.04 + Math.random() * 0.04);
                    const offset = normal.clone().multiplyScalar(Math.cos(angle) * r)
                        .add(binormal.clone().multiplyScalar(Math.sin(angle) * r));
                    points.push(base.clone().add(offset));
                }
                const threadCurve = new THREE.CatmullRomCurve3(points);
                const threadGeom = new THREE.TubeGeometry(threadCurve, threadSegments * 2, 0.16 + Math.random() * 0.08, 10, false); // Thicker threads
                const threadMat = new THREE.MeshPhysicalMaterial({
                    color: 0x8a7c6b, // Rope-like brownish color
                    roughness: 0.85, // High roughness for matte finish
                    metalness: 0.08,
                    transmission: 0.0, // No silkiness
                    thickness: 0.18,
                    ior: 1.2,
                    clearcoat: 0.0, // No clearcoat for matte
                    clearcoatRoughness: 1.0,
                    opacity: 0.98,
                    transparent: true,
                    emissive: 0x000000, // No glow
                    emissiveIntensity: 0.0
                });
                const thread = new THREE.Mesh(threadGeom, threadMat);
                scene.add(thread);
            }
        }

        // Restore tube geometry for the main tunnel
        let tubeGeometry;
        const tubeRadius = 6.5; // Wider tunnel
        const tubularSegments = 200;
        function createTunnel() {
            tubeGeometry = new THREE.TubeGeometry(curve, tubularSegments, tubeRadius, 32, false); // More segments for smoothness
            const tubeMaterial = new THREE.MeshPhysicalMaterial({
                color: 0x181a1e, // Very dark blue/gray for shadow
                roughness: 0.95,
                metalness: 0.05,
                transmission: 0.1,
                thickness: 0.3,
                ior: 1.1,
                clearcoat: 0.2,
                clearcoatRoughness: 0.8,
                opacity: 0.55,
                transparent: true,
                side: THREE.BackSide
            });
            tubeMesh = new THREE.Mesh(tubeGeometry, tubeMaterial);
            scene.add(tubeMesh);
        }

        // Initialize the Three.js scene
        function initThree() {
            // Scene setup
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x000000, 20, 75); // Adjusted fog for smaller tunnel

            // Camera setup
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 0); // Start at the beginning of the tube

            // Renderer setup
            renderer = new THREE.WebGLRenderer({ antialias: true }); // Set alpha to true for a transparent background
            renderer.setClearColor(0xffffff, 1); // Set clear color to transparent
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('three-container').appendChild(renderer.domElement);

            // Create the tube path using a CatmullRomCurve3
            const points = [];
            const tubeLength = 50; // Total length of the tube (reduced)
            const numPoints = 50;   // Number of points defining the curve

            for (let i = 0; i <= numPoints; i++) {
                const x = Math.sin(i * 0.2) * 5; // Wavy path on X
                const y = Math.cos(i * 0.15) * 5; // Wavy path on Y
                const z = (i / numPoints) * -tubeLength; // Linear progression along Z-axis (negative for forward movement)
                points.push(new THREE.Vector3(x, y, z));
            }

            curve = new THREE.CatmullRomCurve3(points);

            // Dramatic, eerie lighting
            const ambientLight = new THREE.AmbientLight(0xf7e7c6, 0.22);
            scene.add(ambientLight);
            pointLight = new THREE.PointLight(0xffffff, 2.2, 90);
            scene.add(pointLight);
            const dirLight = new THREE.DirectionalLight(0xcad6ff, 1.1);
            dirLight.position.set(10, 20, 10);
            scene.add(dirLight);

            // Add web tunnel threads AFTER curve is initialized
            addWebTunnel(curve, tubeRadius, 160, 36); // More threads, more segments
            createTunnel(); // Add the shadowy tunnel wall

            // Get HTML elements
            scrollContainer = document.getElementById('scroll-container');
            scrollContentWrapper = document.getElementById('scroll-content-wrapper');
            contentSections = document.querySelectorAll('.section-content');

            // Set the scrollable height to enable snapping between sections
            scrollContentWrapper.style.height = `${contentSections.length * 100}vh`;

            // Initial update of camera and content positions
            updateSceneAndContent();

            // Event listeners
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('wheel', onWheel, { passive: false }); // Use wheel event for controlled scrolling
            window.addEventListener('touchstart', onTouchStart, { passive: false });
            window.addEventListener('touchend', onTouchEnd, { passive: false });

            addParticles();

            // Debugging logs to identify issues
            console.log('Initializing Three.js with section-based scroll...');
        }

        // Handle window resize
        function onWindowResize() {
            setViewportHeight(); // Adjust height on resize
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);

            // Re-adjust scrollable height on resize
            scrollContentWrapper.style.height = `${contentSections.length * 100}vh`;

            // Snap to the current section's position after resize
            scrollContainer.scrollTop = currentSectionIndex * window.innerHeight;
            updateSceneAndContent();
        }

        // Handle wheel event for section-by-section scrolling
        function onWheel(event) {
            event.preventDefault(); // Prevent default scroll behavior
            if (isAnimating) return;

            const direction = Math.sign(event.deltaY);

            if (direction > 0) {
                // Scrolling down
                if (currentSectionIndex < contentSections.length - 1) {
                    currentSectionIndex++;
                    scrollToSection(currentSectionIndex);
                }
            } else {
                // Scrolling up
                if (currentSectionIndex > 0) {
                    currentSectionIndex--;
                    scrollToSection(currentSectionIndex);
                }
            }
        }

        // Handle touch start event for mobile
        function onTouchStart(event) {
            event.preventDefault();
            touchStartY = event.touches[0].clientY;
        }

        // Handle touch end event for mobile
        function onTouchEnd(event) {
            if (isAnimating) return;

            const touchEndY = event.changedTouches[0].clientY;
            const deltaY = touchEndY - touchStartY;
            const swipeThreshold = 50; // Minimum distance for a swipe

            if (deltaY < -swipeThreshold) { // Swipe up
                if (currentSectionIndex < contentSections.length - 1) {
                    currentSectionIndex++;
                    scrollToSection(currentSectionIndex);
                }
            } else if (deltaY > swipeThreshold) { // Swipe down
                if (currentSectionIndex > 0) {
                    currentSectionIndex--;
                    scrollToSection(currentSectionIndex);
                }
            }
        }

        // Animate scrolling to a specific section
        function scrollToSection(index) {
            isAnimating = true;
            const targetScrollTop = index * window.innerHeight;
            const startScrollTop = scrollContainer.scrollTop;
            const distance = targetScrollTop - startScrollTop;
            const duration = 2200; // Animation duration in ms (faster traverse)
            let startTime = null;

            function animateScroll(currentTime) {
                if (startTime === null) startTime = currentTime;
                const elapsedTime = currentTime - startTime;
                const progress = Math.min(elapsedTime / duration, 1);

                // Easing function for smoother animation
                const easedProgress = 0.5 - 0.5 * Math.cos(progress * Math.PI);
                scrollContainer.scrollTop = startScrollTop + distance * easedProgress;

                updateSceneAndContent();

                if (progress < 1) {
                    requestAnimationFrame(animateScroll);
                } else {
                    isAnimating = false;
                }
            }

            requestAnimationFrame(animateScroll);
        }

        // Animate camera along the tunnel based on scroll position only
        function animate() {
            requestAnimationFrame(animate);
            // Only update scene based on scroll position, not auto-progress
            updateSceneAndContent();
            renderer.render(scene, camera);
        }

        // Get scroll progress (0 to 1) based on scrollContainer
        function getScrollProgress() {
            const scrollTop = scrollContainer.scrollTop;
            const maxScroll = scrollContentWrapper.scrollHeight - window.innerHeight;
            return maxScroll > 0 ? scrollTop / maxScroll : 0;
        }

        // Update camera and scene based on scroll progress
        function updateSceneAndContent() {
            const progress = getScrollProgress();
            const clampedProgress = Math.max(0, Math.min(1, progress));
            const cameraPoint = curve.getPointAt(clampedProgress);
            const cameraTangent = curve.getTangentAt(clampedProgress).normalize();
            camera.position.copy(cameraPoint);
            const lookAtPoint = cameraPoint.clone().add(cameraTangent.multiplyScalar(0.1));
            camera.lookAt(lookAtPoint);
            pointLight.position.copy(cameraPoint);

            // Animate section visibility and scale based on scroll progress
            const sectionScrollProgress = clampedProgress * (contentSections.length - 1);
            contentSections.forEach((section, index) => {
                const distance = Math.abs(index - sectionScrollProgress);
                const opacity = Math.max(0, 1 - distance);
                const scale = 0.5 + 0.5 * Math.max(0, 1 - distance);
                section.style.opacity = opacity;
                section.style.transform = `scale(${scale})`;
            });
        }

        // Initialize Three.js and start the animation when the window loads
        window.onload = function() {
            setViewportHeight();
            initThree();
            animate();
        };
    </script>
</body>
</html>
